    log_base = dict(
        mode=mode,
        action="decision",
        symbol=symbol,
        edge_bps=f"{meta.get('edge_best', 0.0):.6f}",
        need_bps=f"{meta.get('need', 0.0):.6f}",
        hours_left=f"{meta.get('hours_left', 0.0):.3f}",
        exA=exA.id, sideA=sideA, priceA=f"{pA:.8f}", amountA="",
        orderIdA="", exB=exB.id, sideB=sideB, priceB=f"{pB:.8f}", amountB="", orderIdB="",
        notional_usdt=f"{notional_usdt:.2f}", basis_bps=f"{meta.get('basis_bps',0.0):.3f}",
        fill_ratio_A="", fill_ratio_B="",
        expected_funding_pnl_usdt=f"{expected_funding_usdt(meta.get('edge_best',0.0), notional_usdt):.4f}",
        expected_pnl_usdt=f"{expected_funding_usdt(meta.get('edge_best',0.0), notional_usdt):.4f}"
    )

    if dry_run:
        console.print(f"[cyan]DRY-RUN: {exA.id} {sideA} / {exB.id} {sideB} | mode={mode} | notional≈{notional_usdt:.0f}[/cyan]")
        log_base.update(action="dry_run")
        logger.log(log_base)
        return

    try:
        # Preflight for taker pricing (market/last-based)
        ok_pf, reason_pf, _amtA, _amtB = _preflight_both_legs(
            exA, sideA, pA, exB, sideB, pB, symbol, notional_usdt, cfg.leverage
        )
        if mode == "taker" and not ok_pf:
            console.print(f"[yellow]Preflight failed ({reason_pf}); skip entry {symbol}[/yellow]")
            if logger:
                logger.log({**log_base, "action": "preflight_failed", "reason": reason_pf})
            return
            # === TAKER: đặt 2 chân theo kiểu "atomic" với rollback ===
        amtA = _qty_from_notional(exA, symbol, notional_usdt, pA)
        amtB = _qty_from_notional(exB, symbol, notional_usdt, pB)

        if mode == "taker":
            # 1) Gửi chân A
            try:
                oA = _safe_create_order(exA, symbol, "market", sideA, amtA)
            except Exception as e:
                console.print(f"[red]Leg-A failed ({exA.id}): {e}[/red]")
                if logger:
                    logger.log({**log_base, "action": "legA_failed", "exA": exA.id, "exB": exB.id, "error": str(e)})
                return  # chưa mở chân nào, rút

            # 2) Gửi chân B; nếu fail → rollback A (reduceOnly)
            try:
                oB = _safe_create_order(exB, symbol, "market", sideB, amtB)
            except Exception as e:
                console.print(f"[red]Leg-B failed ({exB.id}), rolling back leg-A: {e}[/red]")
                if logger:
                    logger.log({**log_base, "action": "legB_failed_rollback", "orderIdA": oA.get("id", ""), "error": str(e)})
                # rollback: đóng ngay chân A (đối ứng, reduceOnly)
                rb_sideA = "sell" if sideA == "buy" else "buy"
                params = {"reduceOnly": True}
                if getattr(exA, "id", "") == "bybit":
                    params["timeInForce"] = "IOC"
                try:
                    _safe_create_order(exA, symbol, "market", rb_sideA, amtA, None, {"reduceOnly": True})
                except Exception as e2:
                    console.print(f"[red]Rollback failed on {exA.id}: {e2}[/red]")
                    if logger:
                        logger.log({**log_base, "action": "rollback_failed", "error": str(e2)})
                return  # kết thúc vì đã rollback xong

            # 3) Cả hai chân đã vào thành công
            if logger:
                logger.log({
                    **log_base, "action": "placed_taker",
                    "amountA": f"{amtA}", "amountB": f"{amtB}",
                    "orderIdA": oA.get("id",""), "orderIdB": oB.get("id","")
                })
            console.print("[green]Placed taker orders on both legs[/green]")
            try:
                STATE.entry_count += 1
                if TELE:
                    TELE.send(f"ENTER {symbol}: {exA.id} {sideA}/{exB.id} {sideB} notional≈{notional_usdt:.0f} (taker)")
            except Exception:
                pass
            return

        # maker or hybrid -> post-only
        offset = cfg.hybrid_price_offset_bps
        priceA = _maker_price_from_orderbook(exA, symbol, sideA, offset)
        priceB = _maker_price_from_orderbook(exB, symbol, sideB, offset)
        if not priceA or not priceB:
            console.print("[red]Cannot fetch orderbook for maker pricing[/red]")
            if mode == "hybrid":
                return place_delta_neutral(bin_short, notional_usdt, symbol, binance, bybit, dry_run, "taker", cfg, logger, meta)
            return
        # Preflight for maker/hybrid using quoted maker prices
        ok_pf2, reason_pf2, _mAmtA, _mAmtB = _preflight_both_legs(
            exA, sideA, priceA, exB, sideB, priceB, symbol, notional_usdt, cfg.leverage
        )
        if not ok_pf2:
            console.print(f"[yellow]Preflight failed ({reason_pf2}); skip entry {symbol}[/yellow]")
            if logger:
                logger.log({**log_base, "action": "preflight_failed", "reason": reason_pf2})
            return
        amtA = _qty_from_notional(exA, symbol, notional_usdt, priceA)
        amtB = _qty_from_notional(exB, symbol, notional_usdt, priceB)
        paramsA = {"postOnly": True}
        paramsB = {"postOnly": True}
        if getattr(exA, "id", "") == "binanceusdm":
            paramsA["timeInForce"] = "GTX"
        if getattr(exB, "id", "") == "binanceusdm":
            paramsB["timeInForce"] = "GTX"
        oA = _safe_create_order(exA, symbol, "limit", sideA, amtA, priceA, paramsA)
        oB = _safe_create_order(exB, symbol, "limit", sideB, amtB, priceB, paramsB)
        logger.log({**log_base, "action": "placed_maker", "amountA": amtA, "amountB": amtB, "priceA": f"{priceA:.8f}", "priceB": f"{priceB:.8f}", "orderIdA": oA.get("id",""), "orderIdB": oB.get("id","")})
        console.print("[green]Placed maker (post-only) orders[/green]")

        if mode == "maker":
            try:
                STATE.entry_count += 1
                if TELE:
                    TELE.send(f"ENTER {symbol}: maker post-only {exA.id}/{exB.id} notional≈{notional_usdt:.0f}")
            except Exception:
                pass
            return

        # HYBRID wait and evaluate
        time.sleep(max(1, int(cfg.hybrid_wait_seconds)))
        rA = _order_filled_ratio(exA, oA)
        rB = _order_filled_ratio(exB, oB)
        logger.log({**log_base, "action": "hybrid_check", "fill_ratio_A": f"{rA:.4f}", "fill_ratio_B": f"{rB:.4f}"})
        if rA >= cfg.hybrid_min_fill_ratio and rB >= cfg.hybrid_min_fill_ratio:
            console.print("[green]Hybrid maker filled sufficiently. Keeping maker orders.[/green]")
            logger.log({**log_base, "action": "hybrid_keep_maker", "fill_ratio_A": f"{rA:.4f}", "fill_ratio_B": f"{rB:.4f}"})
            try:
                STATE.entry_count += 1
                if TELE:
                    TELE.send(f"ENTER {symbol}: maker-filled rA={rA:.2f}, rB={rB:.2f}")
            except Exception:
                pass
            return
        # cancel + finish with taker for remaining
        _cancel_silent(exA, oA)
        _cancel_silent(exB, oB)
        remA = max(0.0, 1.0 - rA) * notional_usdt
        remB = max(0.0, 1.0 - rB) * notional_usdt
        rem = max(remA, remB)
        if rem < 1:
            logger.log({**log_base, "action": "hybrid_all_filled"})
            return
        tA2 = exA.fetch_ticker(symbol)
        tB2 = exB.fetch_ticker(symbol)
        pA2 = _to_float(tA2.get("last")) or pA
        pB2 = _to_float(tB2.get("last")) or pB
        # Final preflight for taker completion on remaining notional
        ok_pf3, reason_pf3, amtA2, amtB2 = _preflight_both_legs(
            exA, sideA, pA2, exB, sideB, pB2, symbol, rem, cfg.leverage
        )
        if not ok_pf3:
            logger.log({**log_base, "action": "preflight_failed", "reason": f"hybrid_fallback: {reason_pf3}"})
            console.print(f"[yellow]Hybrid fallback preflight failed ({reason_pf3}); skip completing {symbol}[/yellow]")
            return
        oA2 = _safe_create_order(exA, symbol, "market", sideA, amtA2)
        oB2 = _safe_create_order(exB, symbol, "market", sideB, amtB2)
        logger.log({**log_base, "action": "hybrid_fallback_taker", "amountA": amtA2, "amountB": amtB2, "priceA": f"{pA2:.8f}", "priceB": f"{pB2:.8f}", "orderIdA": oA2.get("id",""), "orderIdB": oB2.get("id","")})
        console.print("[green]Hybrid taker completion done[/green]")
        try:
            STATE.entry_count += 1
            if TELE:
                TELE.send(f"ENTER {symbol}: hybrid complete rem≈{rem:.0f} USDT")
        except Exception:
            pass

    except Exception as e:
        console.print(f"[red]Order placement failed: {e}[/red]")
        logger.log({**log_base, "action": "error", "exA": exA.id, "exB": exB.id})
        try:
            if TELE:
                TELE.send(f"ORDER ERROR {symbol}: {e}")
            STATE.last_error = str(e)
        except Exception:
            pass

def close_delta_neutral(symbol: str, binance, bybit, dry_run: bool = False):
    """Close both legs concurrently to minimize lag between exchanges."""
    # Run exits in parallel to reduce any perceived lag
    t1 = threading.Thread(target=_close_leg_reduce_only, args=(binance, symbol))
    t2 = threading.Thread(target=_close_leg_reduce_only, args=(bybit,   symbol))
    t1.start(); t2.start()
    t1.join();  t2.join()
    console.print(f"[green]Closed delta-neutral positions for {symbol}[/green]")
    # Xóa khỏi tracker
    TRADE_TRACKER.clear_symbol(symbol)
    # notify + telemetry
    try:
        STATE.exit_count += 1
        if TELE:
            TELE.send(f"EXIT {symbol}: reduce-only both legs")
    except Exception:
        pass

def _close_leg_reduce_only(ex, symbol: str):
    if not has_creds(ex):
        return
    try:
        positions = ex.fetch_positions([symbol])
    except Exception:
        positions = []
    for p in positions:
        if p.get("symbol") != symbol:
            continue
        contracts = _to_float(p.get("contracts"))
        side = _position_side(p, contracts)
        params = {"reduceOnly": True}
        # Bybit prefers IOC for reduce-only market to ensure immediate execution
        if getattr(ex, "id", "") == "bybit":
            params["timeInForce"] = "IOC"
        # Binance: only include positionSide when in hedge mode; omit in One-way mode
        if getattr(ex, "id", "") == "binanceusdm":
            if _is_binance_hedge_mode(ex):
                if side == "long":
                    params["positionSide"] = "LONG"
                elif side == "short":
                    params["positionSide"] = "SHORT"
            # Faster acknowledgement from Binance
            params["newOrderRespType"] = "RESULT"
        if side == "long" and contracts > 0:
            _safe_create_order(ex, symbol, "market", "sell", abs(contracts), None, params)
        elif side == "short" and contracts < 0:
            _safe_create_order(ex, symbol, "market", "buy",  abs(contracts), None, params)

_LAST_FIX_TS: Dict[str, float] = {}

def _reconcile_legs(symbol: str, binance, bybit, logger: Optional[TradeLogger] = None, size_tol: float = 0.05, cooldown_s: int = 5) -> bool:
    """Return True if legs look consistent, False if we had to fix something.

    Cooldown avoids repeated fixes/alerts when one side lags.
    """
    now = time.time()
    if now - _LAST_FIX_TS.get(symbol, 0.0) < cooldown_s:
        return True

    pos_bin = _get_positions_by_symbol(binance, symbol)
    pos_byb = _get_positions_by_symbol(bybit, symbol)

    open_bin = bool(pos_bin)
    open_byb = bool(pos_byb)

    # 1) One side open, the other closed -> close the open side
    if open_bin ^ open_byb:
        ex_open = binance if open_bin else bybit
        msg = _close_leg_reduce_only_single(ex_open, symbol)
        try:
            if TELE:
                TELE.send(f"ASYMMETRY DETECTED {symbol}: only {ex_open.id} open → {msg}")
        except Exception:
            pass
        if logger:
            logger.log({"action": "asym_fix_one_leg", "symbol": symbol, "exchange": ex_open.id, "message": msg})
        TRADE_TRACKER.clear_symbol(symbol)
        _LAST_FIX_TS[symbol] = now
        return False

    # 2) Both closed -> consistent
    if not open_bin and not open_byb:
        return True

    # 3) Both open -> check side and size
    def _sig(p):
        contracts = _to_float(p.get("contracts", 0))
        side = 1 if contracts > 0 else -1
        qty = abs(contracts)
        return side, qty

    s1, q1 = _sig(pos_bin[0]); s2, q2 = _sig(pos_byb[0])

    # They must be opposite side
    if s1 == s2:
        close_delta_neutral(symbol, binance, bybit)
        try:
            if TELE:
                TELE.send(f"ASYMMETRY DETECTED {symbol}: same-side legs → force-closed both")
        except Exception:
            pass
        if logger:
            logger.log({"action": "asym_fix_same_side", "symbol": symbol, "bin_side": s1, "byb_side": s2})
        TRADE_TRACKER.clear_symbol(symbol)
        _LAST_FIX_TS[symbol] = now
        return False

    # Sizes should be close within tolerance
    if max(q1, q2) > 0 and abs(q1 - q2) / max(q1, q2) > size_tol:
        close_delta_neutral(symbol, binance, bybit)
        try:
            if TELE:
                TELE.send(f"ASYMMETRY DETECTED {symbol}: size mismatch ({q1:g} vs {q2:g}) → force-closed both")
        except Exception:
            pass
        if logger:
            logger.log({"action": "asym_fix_size_mismatch", "symbol": symbol, "qty_bin": q1, "qty_byb": q2})
        TRADE_TRACKER.clear_symbol(symbol)
        _LAST_FIX_TS[symbol] = now
        return False

    return True

# ===== Helpers for Telegram summaries and control =====
def _fmt_usdt(x: float) -> str:
    try:
        return f"{float(x):,.2f}"
    except Exception:
        return str(x)

def _balances_summary(binance, bybit) -> str:
    try:
        b = binance.fetch_balance()
    except Exception:
        b = {}
    try:
        y = bybit.fetch_balance()
    except Exception:
        y = {}
    def pick(d):
        u = d.get("USDT") or {}
        return _to_float(u.get("total")), _to_float(u.get("free")), _to_float(u.get("used"))
    bt, bf, bu = pick(b); yt, yf, yu = pick(y)
    return (
        f"BINANCE — total:{_fmt_usdt(bt)} free:{_fmt_usdt(bf)} used:{_fmt_usdt(bu)}\n"
        f"BYBIT   — total:{_fmt_usdt(yt)} free:{_fmt_usdt(yf)} used:{_fmt_usdt(yu)}"
    )

def _positions_summary(ex) -> List[str]:
    out = []
    try:
        poss = ex.fetch_positions() or []
    except Exception:
        poss = []
    for p in poss:
        contracts = _to_float(p.get("contracts"))
        if contracts == 0:
            continue
        sym = p.get("symbol")
        side = _position_side(p, contracts)
        entry = _to_float(p.get("entryPrice"))
        mark  = _to_float(p.get("markPrice")) or _to_float(p.get("last"))
